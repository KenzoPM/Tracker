# --- en-t√™te du script ---
import os, time, json, hashlib, requests
from datetime import datetime

TRACKR_URL = os.getenv("https://api.the-trackr.com/programmes?region=UK&industry=Finance&season=2026&type=summer-internships")  # ex: https://app.the-trackr.com/api/programmes?... 
DISCORD_WEBHOOK = os.getenv("https://discord.com/api/webhooks/1430168333172605001/unfXITL1Tqhb5hd-l4Gzb18tOJNdKMuFmZ0ckm1SbIHOkNIxGZH0Rl6JIgm3LOJycRfD")
CHECK_EVERY_SECONDS = int(os.getenv("CHECK_EVERY_SECONDS", "300"))
STATE_FILE = os.getenv("STATE_FILE", "seen_offers.json")

if not TRACKR_URL or not DISCORD_WEBHOOK:
    raise SystemExit("‚ö†Ô∏è Config manquante: d√©finis TRACKR_URL et DISCORD_WEBHOOK en variables d'environnement.")
def load_state():
    if os.path.exists(STATE_FILE):
        with open(STATE_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return {"seen_ids": []}

def save_state(state):
    with open(STATE_FILE, "w", encoding="utf-8") as f:
        json.dump(state, f, ensure_ascii=False, indent=2)

def safe_get(d, *keys, default=""):
    for k in keys:
        v = d.get(k)
        if v:
            return str(v).strip()
    return default

def make_id(item):
    native_id = safe_get(item, "id", "_id")
    if native_id:
        return native_id
    base = "|".join([
        safe_get(item, "company", "employer"),
        safe_get(item, "title", "role", "name"),
        safe_get(item, "location", "city"),
        safe_get(item, "url", "apply_url", "link"),
        safe_get(item, "posted_at", "created_at")
    ])
    return hashlib.sha256(base.encode("utf-8")).hexdigest()[:16]

def parse_offers(data):
    if isinstance(data, dict):
        for key in ("results", "data", "items", "offers", "jobs", "programmes"):
            if key in data and isinstance(data[key], list):
                data = data[key]
                break
    if not isinstance(data, list):
        data = []
    offers = []
    for it in data:
        offers.append({
            "id": make_id(it),
            "company": safe_get(it, "company", "employer"),
            "title": safe_get(it, "title", "role", "name", default="Summer Internship"),
            "location": safe_get(it, "location", "city"),
            "url": safe_get(it, "url", "apply_url", "link"),
            "posted_at": safe_get(it, "posted_at", "created_at"),
            "deadline": safe_get(it, "deadline", "close_date"),
        })
    return offers

def send_discord(text: str):
    if not DISCORD_WEBHOOK:
        return
    try:
        requests.post(DISCORD_WEBHOOK, json={"content": text}, timeout=15)
    except requests.RequestException as e:
        print(f"[Discord] Erreur d‚Äôenvoi: {e}")

def check_once(seen_ids):
    headers = {
        "User-Agent": "Mozilla/5.0",
        "Accept": "application/json"
    }
    resp = requests.get(TRACKR_URL, headers=headers, timeout=20)
    resp.raise_for_status()
    data = resp.json()

    offers = parse_offers(data)
    new_offers = [o for o in offers if o["id"] not in seen_ids]

    if new_offers:
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"\n=== üéâ Nouvelles offres d√©tect√©es ({len(new_offers)}) ‚Äî {now} ===")
        lines = []
        for o in new_offers:
            line = f"- {o['company']} ‚Äî {o['title']} ({o['location']})"
            if o["url"]:
                line += f" ‚Üí {o['url']}"
            print(line)
            lines.append(line)
        print("=============================================\n")

        # Envoi Discord (en 1 ou plusieurs messages si c'est long)
        header = f"üéâ **Nouvelles offres d√©tect√©es** ({len(new_offers)})"
        send_discord(header)
        # Discord limite ~2000 caract√®res par message, on d√©coupe si n√©cessaire
        chunk = ""
        for line in lines:
            if len(chunk) + len(line) + 1 > 1800:
                send_discord(chunk)
                chunk = line
            else:
                chunk = (chunk + "\n" + line) if chunk else line
        if chunk:
            send_discord(chunk)

        # Marquer comme vues
        for o in new_offers:
            seen_ids.append(o["id"])
    else:
        print("Pas de nouvelles offres pour le moment.")

    return seen_ids

def main():
    # Petit test de webhook au d√©marrage (facultatif, commentez si vous voulez)
    if DISCORD_WEBHOOK:
        send_discord("‚úÖ Bot Trackr d√©marr√©. Je vous notifie ici s‚Äôil y a de nouvelles offres.")

    state = load_state()
    seen_ids = state.get("seen_ids", [])

    print("D√©marrage du monitoring‚Ä¶ (Ctrl+C pour arr√™ter)")
    print(f"URL : {TRACKR_URL}\nV√©rification toutes les {CHECK_EVERY_SECONDS} secondes.\n")

    while True:
        try:
            seen_ids = check_once(seen_ids)
            save_state({"seen_ids": seen_ids})
        except requests.RequestException as e:
            print(f"[Erreur r√©seau] {e}")
        except Exception as e:
            print(f"[Erreur] {e}")
        time.sleep(CHECK_EVERY_SECONDS)

if __name__ == "__main__":
    main()
